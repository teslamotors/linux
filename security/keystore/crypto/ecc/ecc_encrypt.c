/*
 *
 * Intel Keystore Linux driver
 * Copyright (c) 2013, Intel Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms and conditions of the GNU General Public License,
 * version 2, as published by the Free Software Foundation.
 *
 * This program is distributed in the hope it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 */

#include <linux/errno.h>
#include <linux/kernel.h>
#include <linux/slab.h>
#include <crypto/sha.h>

#include "keystore_debug.h"

#include "ecc.h"
#include "ecies.h"
#include "utils.h"

struct transport_format {
	uint32_t curve; /* ECC Curve ID */
	uint32_t dhkeylen;
	uint32_t textlen;
	uint32_t maclen;
};

#define NUM_ECC_BYTES (NUM_ECC_DIGITS * sizeof(uint32_t))

/**
 * Convert hex value to int format.
 *
 * @param buf pointer to memory block.
 * @param start offset in memory block.
 *
 * @return number generated by bit shifting.
 */
static int hextoInt(const void *buf, int start)
{
	int val = 0;
	int end = start+4;
	uint8_t *p = (uint8_t *)buf;

	while (start < end) {
		val = val | p[start] << 8*start;
		start++;
	}
	return val;
}

/**
 * Calculate size of serialized cipher structure.
 *
 * @param cipher Pointer to the cipher structure.
 *
 * @return Size in bytes.
 */
static unsigned int get_serialized_cipher_size(const ecc_cipher_t *cipher)
{
	if (!cipher)
		return 0;

	return (uint32_t)sizeof(struct transport_format) +
		cipher->dhkeylen + cipher->maclen + cipher->textlen;
}

/**
 * Serialize cipher structure.
 *
 * @param cipher Pointer to the cipher structure.
 * @param data Output memory block pointer.
 * @param size Output memory block size.
 *
 * @return -1 on error or serialized data size in bytes.
 */
static int serialize_cipher(const ecc_cipher_t *cipher,
			    uint8_t *data, unsigned int size)
{
	struct transport_format *header = (struct transport_format *) data;
	unsigned int len;

	if (!cipher || !data || !cipher->dhkey ||
			!cipher->mac || !cipher->text)
		return -EFAULT;

	len = get_serialized_cipher_size(cipher);
	ks_info(KBUILD_MODNAME ": serialize_cipher: new len: %u, available len: %u\n",
		len, size);

	if (size < len)
		return -EINVAL;

	/* move the encrypted data block carefully to the end
	 * (allows to use the same block for encrypted data
	 * and serialized form)
	 */
	memmove(data +
		sizeof(struct transport_format) +
		cipher->dhkeylen +
		cipher->maclen,
		cipher->text, cipher->textlen);

	/* fill in transport structure */
	header->curve = cipher->curve;
	header->dhkeylen = cipher->dhkeylen;
	header->maclen = cipher->maclen;
	header->textlen = cipher->textlen;

	/* copy public key */
	memcpy(data + sizeof(struct transport_format), cipher->dhkey,
			cipher->dhkeylen);

	/* copy MAC */
	memcpy(data + sizeof(struct transport_format) + cipher->dhkeylen,
			cipher->mac, cipher->maclen);

	return len;
}


/**
 * Encrypt a block of data using ECC (ECIES).
 *
 * @param key Public key pointer (raw data).
 * @param data Block of data to be encrypted.
 * @param data_size Size of data in bytes.
 * @param output Block of data for the result.
 * @param output_size Size of output data block.
 *
 * @return The number of bytes written into output block if
 * OK or negative error code (see errno).
 */
int keystore_ecc_encrypt(const struct keystore_ecc_public_key *key,
			 const void *data, unsigned int data_size,
			 void *output, unsigned int output_size)
{
	uint8_t dhkey_buffer[2 * NUM_ECC_BYTES + 1];
	uint8_t mac_buffer[SHA256_DIGEST_SIZE];
	ecc_cipher_t cipher;
	int res;

	/* Verify input parameters */
	if (!key || !data || !output)
		return -EFAULT;

	if (!data_size || (output_size < data_size))
		return -EINVAL;

	keystore_hexdump("Public ECC key", key, sizeof(struct EccPoint));

	/* Allocate cipher object for ecies_encrypt(). */
	/* Ecies will populate this and set lengths to actual sizes */
	cipher.curve = ECC_CURVE; /* ECC curve size in 32-bit words */
	cipher.dhkey = dhkey_buffer; /* temporary buffer */
	cipher.dhkeylen = sizeof(dhkey_buffer); /* no compression; 1 byte */
	cipher.text = output; /* output buffer */
	cipher.textlen = data_size; /* XOR encryption */
	cipher.mac = mac_buffer; /* HMAC buffer */
	cipher.maclen = sizeof(mac_buffer); /* HMAC-SHA-256 output */

	/* Validate public key */
	if (!ecc_valid_public_key((struct EccPoint *)key)) {
		ks_debug(KBUILD_MODNAME ": %s: Public key is not valid\n",
			__func__);
		return -EKEYREJECTED;
	}

	/* Encrypt the block of data, output has the same size */
	res = ecies_encrypt(&cipher, (struct EccPoint *)key,
			    data, data_size);
	if (res != 0) {
		ks_debug(KBUILD_MODNAME ": %s: ECIES encrypt error %d\n",
			__func__, res);
		return -EINVAL;
	}

	keystore_hexdump("DH Key", dhkey_buffer, sizeof(dhkey_buffer));
	keystore_hexdump("MAC", mac_buffer, sizeof(mac_buffer));
	keystore_hexdump("Plain", data, data_size);
	keystore_hexdump("Cipher", cipher.text, cipher.textlen);

	/* Serialize the cipher structure */
	res = serialize_cipher(&cipher, output, output_size);

	if (res < 0)
		return res;

	return 0;
}

/**
 * Decrypt a block of data using ECC (ECIES).
 *
 * @param key Private key pointer (raw data).
 * @param data Block of data to be decrypted.
 * @param data_size Size of data in bytes.
 * @param output Block of data for the result.
 * @param output_size Size of output data block.
 *
 * @return The number of bytes written into output block if OK or negative
 * error code (see errno).
 */
int keystore_ecc_decrypt(const uint32_t *key,
			 const void *data, unsigned int data_size,
			 void *output, unsigned int output_size)
{
	uint8_t dhkey_buffer[2 * NUM_ECC_BYTES + 1];
	uint8_t mac_buffer[SHA256_DIGEST_SIZE];
	uint32_t textlen;
	ecc_cipher_t cipher;
	EccPoint pub_key;
	int res;

	FUNC_BEGIN;

	/* Verify input parameters */
	if (!key || !data || !output)
		return -EFAULT;

	/*Validate input buffer by validating header */
	if ((hextoInt(data, 0) != ECC_CURVE) ||
			(hextoInt(data, 4) != sizeof(dhkey_buffer)) ||
			hextoInt(data, 8) < 1 ||
			(hextoInt(data, 12) != sizeof(mac_buffer))) {
		return -EINVAL;
	}
	/* Public key generation just for debugging */
	ecc_get_public_key(key, &pub_key);
	keystore_hexdump("Public ECC key", &pub_key, sizeof(pub_key));

	/* Allocate cipher object for ecies_decrypt(). */
	/* Ecies will populate this and set lengths to actually used sizes */
	textlen = (uint32_t)hextoInt(data, 8);
	cipher.curve = ECC_CURVE; /* ECC curve size in 32-bit words */
	cipher.dhkey = dhkey_buffer; /* temporary buffer */
	cipher.dhkeylen = sizeof(dhkey_buffer); /* no compression, 1 byte hdr */
	cipher.text = kzalloc(textlen, GFP_KERNEL); /* output buffer */
	cipher.textlen = textlen;/* XOR encryption */
	cipher.mac = mac_buffer; /* HMAC buffer */
	cipher.maclen = sizeof(mac_buffer); /* HMAC-SHA-256 output */

	if (!cipher.text) {
		ks_warn(KBUILD_MODNAME ": %s: Out of memory %d\n",
			__func__, textlen);
		return -ENOMEM;
	}

	/*copy dh key from blob */
	memcpy(&dhkey_buffer,
	       (data + sizeof(struct transport_format)),
	       sizeof(dhkey_buffer));
	/*copy mac from blob */
	memcpy(&mac_buffer,
	       (data + sizeof(struct transport_format) + sizeof(dhkey_buffer)),
	       sizeof(mac_buffer));
	/*copy text from blob */
	memcpy(cipher.text,
	       (data + sizeof(struct transport_format) + sizeof(dhkey_buffer) +
		sizeof(mac_buffer)),
	       cipher.textlen);

	keystore_hexdump("DH Key", dhkey_buffer, sizeof(dhkey_buffer));
	keystore_hexdump("MAC", mac_buffer, sizeof(mac_buffer));
	keystore_hexdump("Cipher", cipher.text, cipher.textlen);

	/* Decrypt the block of data */
	res = ecies_decrypt((uint8_t *)output, &output_size, key, &cipher);
	if (res != 0) {
		ks_warn(KBUILD_MODNAME ": %s: ECIES decrypt error %d\n",
			__func__, res);
		res = -EINVAL;
	}

	kzfree(cipher.text);

	FUNC_RES(res);
	return res;
}
/* end of file */
