/* SPDX-License-Identifier: ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause) */
/*
 * Copyright (C) 2015-2018 Intel Corp. All rights reserved
 */
#ifndef _UAPI_LINUX_RPMB_H_
#define _UAPI_LINUX_RPMB_H_

#include <linux/types.h>

/**
 * enum rpmb_type - type of underlying storage technology
 *
 * @RPMB_TYPE_ANY   : any type used for search only
 * @RPMB_TYPE_EMMC  : eMMC (JESD84-B50.1)
 * @RPMB_TYPE_UFS   : UFS (JESD220)
 * @RPMB_TYPE_NVME  : NVM Express Revision 1.3a
 * @RPMB_TYPE_SIM   : Simulation device.
 * @RPMB_TYPE_MAX   : upper sentinel
 */
enum rpmb_type {
	RPMB_TYPE_ANY = 0,
	RPMB_TYPE_EMMC,
	RPMB_TYPE_UFS,
	RPMB_TYPE_NVME,

	RPMB_TYPE_SIM = 0x0100,
	RPMB_TYPE_MAX = RPMB_TYPE_SIM | RPMB_TYPE_NVME,
};

#define RPMB_TYPE_HW(_type) ((_type) & 0xFF)

/**
 * struct rpmb_frame_jdec - rpmb frame as defined by JDEC specs
 *
 * @stuff        : stuff bytes
 * @key_mac      : The authentication key or the message authentication
 *                 code (MAC) depending on the request/response type.
 *                 The MAC will be delivered in the last (or the only)
 *                 block of data.
 * @data         : Data to be written or read by signed access.
 * @nonce        : Random number generated by the host for the requests
 *                 and copied to the response by the RPMB engine.
 * @write_counter: Counter value for the total amount of the successful
 *                 authenticated data write requests made by the host.
 * @addr         : Address of the data to be programmed to or read
 *                 from the RPMB. Address is the serial number of
 *                 the accessed block (half sector 256B).
 * @block_count  : Number of blocks (half sectors, 256B) requested to be
 *                 read/programmed.
 * @result       : Includes information about the status of the write counter
 *                 (valid, expired) and result of the access made to the RPMB.
 * @req_resp     : Defines the type of request and response to/from the memory.
 */
struct rpmb_frame_jdec {
	__u8   stuff[196];
	__u8   key_mac[32];
	__u8   data[256];
	__u8   nonce[16];
	__be32 write_counter;
	__be16 addr;
	__be16 block_count;
	__be16 result;
	__be16 req_resp;
} __attribute__((packed));

/* length of the part of the frame used for HMAC computation */
#define rpmb_jdec_hmac_data_len \
	(sizeof(struct rpmb_frame_jdec) - \
	 offsetof(struct rpmb_frame_jdec, data))

#define RPMB_PROGRAM_KEY       0x0001    /* Program RPMB Authentication Key */
#define RPMB_GET_WRITE_COUNTER 0x0002    /* Read RPMB write counter */
#define RPMB_WRITE_DATA        0x0003    /* Write data to RPMB partition */
#define RPMB_READ_DATA         0x0004    /* Read data from RPMB partition */
#define RPMB_RESULT_READ       0x0005    /* Read result request  (Internal) */

#define RPMB_REQ2RESP(_OP) ((_OP) << 8)
#define RPMB_RESP2REQ(_OP) ((_OP) >> 8)

/**
 * enum rpmb_op_result - rpmb operation results
 *
 * @RPMB_ERR_OK:       operation successful
 * @RPMB_ERR_GENERAL:  general failure
 * @RPMB_ERR_AUTH:     mac doesn't match or ac calculation failure
 * @RPMB_ERR_COUNTER:  counter doesn't match or counter increment failure
 * @RPMB_ERR_ADDRESS:  address out of range or wrong address alignment
 * @RPMB_ERR_WRITE:    data, counter, or result write failure
 * @RPMB_ERR_READ:     data, counter, or result read failure
 * @RPMB_ERR_NO_KEY:   authentication key not yet programmed
 *
 * @RPMB_ERR_COUNTER_EXPIRED:  counter expired
 */
enum rpmb_op_result {
	RPMB_ERR_OK      = 0x0000,
	RPMB_ERR_GENERAL = 0x0001,
	RPMB_ERR_AUTH    = 0x0002,
	RPMB_ERR_COUNTER = 0x0003,
	RPMB_ERR_ADDRESS = 0x0004,
	RPMB_ERR_WRITE   = 0x0005,
	RPMB_ERR_READ    = 0x0006,
	RPMB_ERR_NO_KEY  = 0x0007,

	RPMB_ERR_COUNTER_EXPIRED = 0x0080
};

#define RPMB_F_READ       0UL
#define RPMB_F_WRITE     (1UL << 0)
#define RPMB_F_REL_WRITE (1UL << 1)

enum rpmb_auth_method {
	RPMB_HMAC_ALGO_SHA_256 = 0,
};

/**
 * struct rpmb_cmd - rpmb access command
 *
 * @flags: command flags
 *      0 - read command
 *      1 - write command RPMB_F_WRITE
 *      2 - reliable write RPMB_F_REL_WRITE
 * @nframes: number of rpmb data frames in the command.
 *           0 means 1 frame with meta data only.
 * @frames_ptr:  a pointer to the list of rpmb frames
 */
struct rpmb_ioc_cmd {
	__u32 flags;
	__u32 nframes;
	__aligned_u64 frames_ptr;
};

#define rpmb_ioc_cmd_set_frames(_cmd, _ptr) \
	(_cmd).frames_ptr = (__aligned_u64)(intptr_t)(_ptr)

#define rpmb_ioc_cmd_set(_cmd, _flags, _ptr, _n) do {        \
	struct rpmb_ioc_cmd *icmd = &(_cmd);                 \
	icmd->flags = (_flags);                              \
	icmd->nframes = (_n);                                \
	icmd->frames_ptr = (__aligned_u64)(intptr_t)(_ptr);  \
} while (0)

#define rpmb_ioc_frames_len_jdec(_n) \
	(((_n) ?: 1) * sizeof(struct rpmb_frame_jdec))

/**
 * struct rpmb_ioc_seq_cmd - rpmb command sequence
 *
 * @num_of_cmds: number of commands
 * @cmds: list of rpmb commands
 */
struct rpmb_ioc_seq_cmd {
	__u64 num_of_cmds;
	struct rpmb_ioc_cmd cmds[0];
}  __attribute__((packed));

/**
 * struct rpmb_ioc_ver_cmd - rpmb api version
 *
 * @api_version: rpmb API version.
 */
struct rpmb_ioc_ver_cmd {
	__u32 api_version;
} __attribute__((packed));

/**
 * struct rpmb_ioc_ver_cmd - rpmb api version
 *
 * @device_type: underlying storage device type
 * @target: rpmb target/region within RPMB partition.
 * @capacity: storage capacity
 * @block_size: storage data block size
 * @wr_cnt_max: maximal number of block that can be written in a single request.
 * @rd_cnt_max: maximal number of block that can be read in a single request.
 * @auth_method: authentication method: currently always HMAC_SHA_256
 * @reserved: reserved to align to 4 bytes.
 */
struct rpmb_ioc_cap_cmd {
	__u16 device_type;
	__u16 target;
	__u16 capacity;
	__u16 block_size;
	__u16 wr_cnt_max;
	__u16 rd_cnt_max;
	__u16 auth_method;
	__u16 reserved;
}  __attribute__((packed));

#define RPMB_IOC_VER_CMD _IOR(0xB5, 80,  struct rpmb_ioc_ver_cmd)
#define RPMB_IOC_CAP_CMD _IOR(0xB5, 81,  struct rpmb_ioc_cap_cmd)
#define RPMB_IOC_SEQ_CMD _IOWR(0xB5, 82, struct rpmb_ioc_seq_cmd)

#endif /* _UAPI_LINUX_RPMB_H_ */
